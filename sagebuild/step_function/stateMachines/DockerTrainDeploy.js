var fs=require('fs')
var _=require('lodash')
var Promise=require('bluebird')

module.exports={
    "Comment": "",
    "StartAt": "start",
    "States": {
        "start":{
            Type:"Pass",
            Next:"initialize",
        },
        "initialize":{
            Type:"Task",
            Resource:"${StepLambdaInitialize.Arn}",
            Next:"listmodels",
        },
        "listmodels":{
            Type:"Task",
            Resource:"${StepLambdaListModels.Arn}",
            ResultPath:"$.params.models",
            Next:"IfBuild",
        },
        "IfBuild":{
            Type:"Choice",
            Choices:[{
                Variable:`$.params.build`,
                BooleanEquals:true,
                Next:`buildImages` 
            },{
                Variable:`$.params.build`,
                BooleanEquals:false,
                Next:`IfTrain` 
            }],
            Default:`buildImages`
        },
        "buildImages":{
            Type: "Parallel",
            Branches:[build('Training'),build('Inference')],
            ResultPath:"$.outputs.build",
            Next:"IfTrain"
        },
        "IfTrain":{
            Type:"Choice",
            Choices:[{
                Variable:`$.params.train`,
                BooleanEquals:true,
                Next:`getTrainingConfig` 
            },{
                Variable:`$.params.train`,
                BooleanEquals:false,
                Next:`getArtifact` 
            }],
            Default:`getTrainingConfig`
        },
        "getArtifact":{
            Type:"Task",
            Resource:"${StepLambdaGetArtifact.Arn}",
            Next:"getModelConfig",
        },
        "getTrainingConfig":{
            Type:"Task",
            InputPath:"$",
            Resource:"${LambdaVariables.TrainingConfig}",
            ResultPath:"$.args.training",
            Next:"getDataConfig"
        },
        "getDataConfig":{
            Type:"Task",
            Resource:"${StepLambdaGetDataConfig.Arn}",
            ResultPath:'$.args.training.InputDataConfig',
            Next:"startTraining"
        },
        "startTraining":{
            Type:"Task",
            InputPath:"$",
            Resource:"${StepLambdaStartTraining.Arn}",
            ResultPath:"$.outputs.training",
            Next:"waitForTraining"
        },
        "waitForTraining":{
            Type:"Wait",
            Seconds:30,
            Next:"getTrainingStatus"
        },
        "getTrainingStatus":{
            Type:"Task",
            Resource:"${StepLambdaTrainingStatus.Arn}",
            ResultPath:"$.status.training",
            Next:"checkTrainingStatus"
        },
        "checkTrainingStatus":{
            Type:"Choice",
            Choices:[{
                Variable:`$.status.training.TrainingJobStatus`,
                StringEquals:"InProgress",
                Next:`waitForTraining` 
            },{
                Variable:`$.status.training.TrainingJobStatus`,
                StringEquals:"Completed",
                Next:`getModelConfig` 
            }],
            Default:`trainingFail`
        },
        "trainingFail":{
            Type:"Task",
            Resource:"${StepLambdaNotificationFail.Arn}",
            Next:"Fail"
        },
        "getModelConfig":{
            Type:"Task",
            Resource:"${LambdaVariables.ModelConfig}",
            ResultPath:"$.args.model",
            Next:"createModel"
        },
        "createModel":{
            Type:"Task",
            Resource:"${StepLambdaCreateModel.Arn}",
            ResultPath:"$.outputs.models",
            Next:"getEndpointConfig"
        },
        "getEndpointConfig":{
            Type:"Task",
            InputPath:"$",
            Resource:"${LambdaVariables.EndpointConfig}",
            ResultPath:"$.args.endpoint",
            Next:"createEndpointConfig"
        },
        "createEndpointConfig":{
            Type:"Task",
            Resource:"${StepLambdaCreateEndpointConfig.Arn}",
            ResultPath:"$.outputs.endpoint",
            Next:"updateEndpoint"
        },
        "updateEndpoint":{
            Type:"Task",
            Resource:"${StepLambdaUpdateEndpoint.Arn}",
            ResultPath:"$.outputs.deploy",
            Next:"waitForEndpoint"
        },
        "waitForEndpoint":{
            Type:"Wait",
            Seconds:10,
            Next:"endpointStatus"
        },
        "endpointStatus":{
            Type:"Task",
            Resource:"${StepLambdaEndpointStatus.Arn}",
            ResultPath:"$.status.endpoint",
            Next:"endpointCheck"
        },
        "endpointCheck":{
            Type:"Choice",
            Choices:[{
                Or:[{
                    Variable:`$.status.endpoint.EndpointStatus`,
                    StringEquals:"Creating",
                },{
                    Variable:`$.status.endpoint.EndpointStatus`,
                    StringEquals:"Updating",
                }],
                Next:`waitForEndpoint` 
            },{
                Variable:`$.status.endpoint.EndpointStatus`,
                StringEquals:"InService",
                Next:`Success` 
            }],
            Default:`endpointRollbackClear`
        },
        "endpointRollbackClear":{
            Type:"Task",
            Resource:"${StepLambdaRollbackClear.Arn}",
            Next:"endpointRollbackClearStatus"
        },
        "endpointRollbackClearStatus":{
            Type:"Task",
            Resource:"${StepLambdaEndpointStatus.Arn}",
            ResultPath:"$.status.endpoint",
            Next:"waitForRollbackClear"
        },
        "waitForRollbackClear":{
            Type:"Wait",
            Seconds:10,
            Next:"endpointRollbackClearCheck"
        },
        "endpointRollbackClearCheck":{
            Type:"Choice",
            Choices:[{
                Or:[{
                    Variable:`$.status.endpoint.EndpointStatus`,
                    StringEquals:"Deleting",
                },{
                    Variable:`$.status.endpoint.EndpointStatus`,
                    StringEquals:"Failed",
                }],
                Next:"endpointRollbackClearStatus" 
            },{
                Variable:`$.endpoint.EndpointStatus`,
                StringEquals:"Empty",
                Next:`endpointRollback` 
            }],
            Default:`endpointRollback`
        },
        "endpointRollback":{
            Type:"Task",
            Resource:"${StepLambdaRollback.Arn}",
            Next:"waitForRollback"
        },
        "waitForRollback":{
            Type:"Wait",
            Seconds:10,
            Next:"endpointRollbackStatus"
        },
        "endpointRollbackStatus":{
            Type:"Task",
            Resource:"${StepLambdaEndpointStatus.Arn}",
            ResultPath:"$.status.endpoint",
            Next:"endpointRollbackCheck",
        },
        "endpointRollbackCheck":{
            Type:"Choice",
            Choices:[{
                Or:[{
                    Variable:`$.status.endpoint.EndpointStatus`,
                    StringEquals:"Creating",
                },{
                    Variable:`$.status.endpoint.EndpointStatus`,
                    StringEquals:"Updating",
                }],
                Next:`waitForRollback` 
            },{
                Or:[{
                    Variable:`$.endpoint.EndpointStatus`,
                    StringEquals:"InService",
                },{
                    Variable:`$.endpoint.EndpointStatus`,
                    StringEquals:"Empty",
                }],
                Next:"deleteEndpointConfig"
            }],
            Default:"deleteEndpointConfig"
        },
        "deleteEndpointConfig":{
            Type:"Task",
            Resource:"${StepLambdaDeleteEndpointConfig.Arn}",
            ResultPath:"$.outputs.deleteEndpointConfig",
            Next:"deleteModel"
        },
        "deleteModel":{
            Type:"Task",
            Resource:"${StepLambdaDeleteModel.Arn}",
            ResultPath:"$.outputs.deleteModel",
            Next:"endpointFail"
        },
        "endpointFail":{
            Type:"Task",
            Resource:"${StepLambdaNotificationFail.Arn}",
            Next:"Fail"
        },
        "Success": {
            Type:"Task",
            Resource:"${StepLambdaNotificationSuccess.Arn}",
            End:true
        },
        "Fail":{
            Type:"Fail"
        }
    }
}

function build(name){
    return {
        StartAt:`startBuildImage${name}`,
        States:_.mapKeys({
            "startBuildImage":{
                Type:"Pass",
                Result:{
                    projectName:"${ImageBuild}",
                    SNSTopic:"${TrainStatusTopic}",
                    tag:name
                },
                Next:`buildImagePath${name}`
            },
            "buildImagePath":{
                Type:"Task",
                Resource:`\${LambdaVariables.${name}DockerfilePath}`,
                ResultPath:`$.dockerfile_path`,
                Next:`buildImage${name}`
            },
            "buildImage":{
                Type:"Task",
                Resource:"${StepLambdaStartBuild.Arn}",
                ResultPath:`$.outputs.build`,
                Next:`wait${name}`
            },
            "wait":{
                Type:"Wait",
                Seconds:5,
                Next:`buildStatus${name}`
            },
            "buildStatus":{
                Type:"Task",
                Resource:"${StepLambdaBuildStatus.Arn}",
                ResultPath:`$.status.build`,
                Next:`checkImage${name}`
            },
            "checkImage":{
                Type:"Choice",
                Choices:[{
                    Variable:`$.status.build.buildStatus`,
                    StringEquals:"IN_PROGRESS",
                    Next:`wait${name}` 
                },{
                    Variable:`$.status.build.buildStatus`,
                    StringEquals:"SUCCEEDED",
                    Next:`EndBuild${name}` 
                }],
                Default:`FailBuildNotification${name}`
            },
            "EndBuild":{
                Type:"Pass",
                End:true
            },
            "FailBuildNotification":{
                Type:"Task",
                Resource:"${StepLambdaNotificationFail.Arn}",
                Next:`FailBuild${name}`
            },
            "FailBuild":{
                Type:"Fail"
            }
        },(x,key)=>`${key}${name}`)
    }
}
